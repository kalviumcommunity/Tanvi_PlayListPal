# spotify_service.py - Spotify API Integration for Playlist Pal

import os
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import json
from dotenv import load_dotenv
import streamlit as st
from typing import List, Dict, Optional
import time

load_dotenv()

class SpotifyPlaylistManager:
    """
    Handles all Spotify API interactions for playlist creation and management.
    Demonstrates Function Calling and API Integration concepts.
    """
    
    def __init__(self):
        self.client_id = os.getenv("SPOTIPY_CLIENT_ID")
        self.client_secret = os.getenv("SPOTIPY_CLIENT_SECRET")
        self.redirect_uri = os.getenv("SPOTIPY_REDIRECT_URI", "http://127.0.0.1:8888/callback")
        
        self.scope = "playlist-modify-public playlist-modify-private user-library-read user-top-read"
        
        self.sp = None
        self._initialize_spotify_client()
    
    def _initialize_spotify_client(self):
        """Initialize Spotify client with proper authentication"""
        try:
            if self.client_id and self.client_secret:
                auth_manager = SpotifyOAuth(
                    client_id=self.client_id,
                    client_secret=self.client_secret,
                    redirect_uri=self.redirect_uri,
                    scope=self.scope,
                    cache_path=".spotify_cache"
                )
                self.sp = spotipy.Spotify(auth_manager=auth_manager)
                return True
            else:
                st.error("Spotify credentials not found in environment variables")
                return False
        except Exception as e:
            st.error(f"Failed to initialize Spotify client: {e}")
            return False
    
    def is_authenticated(self) -> bool:
        """Check if user is authenticated with Spotify"""
        try:
            if self.sp:
                # Try to get current user info
                user = self.sp.current_user()
                return user is not None
        except:
            return False
        return False
    
    def get_user_info(self) -> Optional[Dict]:
        """Get current user information"""
        try:
            if self.sp:
                return self.sp.current_user()
        except Exception as e:
            st.error(f"Error getting user info: {e}")
        return None
    
    def search_tracks(self, search_terms: List[str], limit: int = 50) -> List[Dict]:
        """
        Search for tracks based on search terms generated by AI
        """
        if not self.sp:
            st.error("Spotify client not initialized")
            return []
        
        all_tracks = []
        seen_track_ids = set()
        
        try:
            for term in search_terms:
                # Search for tracks with the term
                results = self.sp.search(q=term, type='track', limit=limit)
                
                for track in results['tracks']['items']:
                    track_id = track['id']
                    if track_id not in seen_track_ids:
                        seen_track_ids.add(track_id)
                        
                        # Extract relevant track information
                        track_info = {
                            'id': track['id'],
                            'name': track['name'],
                            'artist': ', '.join([artist['name'] for artist in track['artists']]),
                            'album': track['album']['name'],
                            'duration_ms': track['duration_ms'],
                            'popularity': track['popularity'],
                            'preview_url': track['preview_url'],
                            'external_urls': track['external_urls'],
                            'search_term': term
                        }
                        all_tracks.append(track_info)
                
                # Add small delay to respect API rate limits
                time.sleep(0.1)
        
        except Exception as e:
            st.error(f"Error searching tracks: {e}")
        
        return all_tracks
    
    def get_audio_features(self, track_ids: List[str]) -> List[Dict]:
        """
        Get audio features for tracks (for similarity analysis)
        """
        if not self.sp:
            return []
        
        try:
            # Spotify API accepts max 100 track IDs at once
            features = []
            for i in range(0, len(track_ids), 100):
                batch = track_ids[i:i+100]
                batch_features = self.sp.audio_features(batch)
                features.extend([f for f in batch_features if f is not None])
                time.sleep(0.1)  # Rate limiting
            
            return features
        except Exception as e:
            st.error(f"Error getting audio features: {e}")
            return []
    
    def create_playlist(self, user_id: str, playlist_name: str, description: str = "", public: bool = True) -> Optional[str]:
        """
        Create a new playlist for the user
        """
        if not self.sp:
            st.error("Spotify client not initialized")
            return None
        
        try:
            playlist = self.sp.user_playlist_create(
                user=user_id,
                name=playlist_name,
                public=public,
                description=description
            )
            return playlist['id']
        except Exception as e:
            st.error(f"Error creating playlist: {e}")
            return None
    
    def add_tracks_to_playlist(self, playlist_id: str, track_ids: List[str]) -> bool:
        """
        Add tracks to an existing playlist
        """
        if not self.sp:
            st.error("Spotify client not initialized")
            return False
        
        try:
            # Spotify API accepts max 100 tracks at once
            for i in range(0, len(track_ids), 100):
                batch = track_ids[i:i+100]
                track_uris = [f"spotify:track:{track_id}" for track_id in batch]
                self.sp.playlist_add_items(playlist_id, track_uris)
                time.sleep(0.1)  # Rate limiting
            
            return True
        except Exception as e:
            st.error(f"Error adding tracks to playlist: {e}")
            return False
    
    def get_user_playlists(self, limit: int = 50) -> List[Dict]:
        """
        Get user's existing playlists
        """
        if not self.sp:
            return []
        
        try:
            playlists = self.sp.current_user_playlists(limit=limit)
            return playlists['items']
        except Exception as e:
            st.error(f"Error getting user playlists: {e}")
            return []
    
    def get_recommendations(self, seed_tracks: List[str] = None, seed_artists: List[str] = None, 
                          seed_genres: List[str] = None, target_features: Dict = None, limit: int = 20) -> List[Dict]:
        """
        Get track recommendations based on seeds and target features
        """
        if not self.sp:
            return []
        
        try:
            # Ensure we don't exceed the 5 seed limit
            total_seeds = len(seed_tracks or []) + len(seed_artists or []) + len(seed_genres or [])
            if total_seeds > 5:
                # Prioritize tracks, then artists, then genres
                if seed_tracks and len(seed_tracks) > 2:
                    seed_tracks = seed_tracks[:2]
                if seed_artists and len(seed_artists) > 2:
                    seed_artists = seed_artists[:2]
                if seed_genres and len(seed_genres) > 1:
                    seed_genres = seed_genres[:1]
            
            recommendations = self.sp.recommendations(
                seed_tracks=seed_tracks,
                seed_artists=seed_artists,
                seed_genres=seed_genres,
                limit=limit,
                **target_features if target_features else {}
            )
            
            return recommendations['tracks']
        except Exception as e:
            st.error(f"Error getting recommendations: {e}")
            return []
    
    def get_available_genres(self) -> List[str]:
        """
        Get list of available genre seeds for recommendations
        """
        if not self.sp:
            return []
        
        try:
            genres = self.sp.recommendation_genre_seeds()
            return genres['genres']
        except Exception as e:
            st.error(f"Error getting available genres: {e}")
            return []
    
    def analyze_playlist_for_similarity(self, track_ids: List[str]) -> Dict:
        """
        Analyze a playlist's audio features for similarity metrics
        """
        features = self.get_audio_features(track_ids)
        if not features:
            return {}
        
        # Calculate average features
        feature_keys = ['danceability', 'energy', 'speechiness', 'acousticness', 
                       'instrumentalness', 'liveness', 'valence', 'tempo']
        
        avg_features = {}
        for key in feature_keys:
            values = [f[key] for f in features if f and key in f]
            if values:
                avg_features[key] = sum(values) / len(values)
        
        return {
            'average_features': avg_features,
            'total_tracks': len(features),
            'feature_diversity': self._calculate_feature_diversity(features, feature_keys)
        }
    
    def _calculate_feature_diversity(self, features: List[Dict], feature_keys: List[str]) -> Dict:
        """
        Calculate how diverse the playlist is in terms of audio features
        """
        diversity = {}
        for key in feature_keys:
            values = [f[key] for f in features if f and key in f]
            if values:
                import statistics
                diversity[key] = {
                    'std_dev': statistics.stdev(values) if len(values) > 1 else 0,
                    'range': max(values) - min(values)
                }
        
        return diversity

# Utility functions for Streamlit integration
def get_spotify_auth_url() -> str:
    """Get Spotify authorization URL for manual authentication"""
    client_id = os.getenv("SPOTIPY_CLIENT_ID")
    redirect_uri = os.getenv("SPOTIPY_REDIRECT_URI", "http://127.0.0.1:8888/callback")
    scope = "playlist-modify-public playlist-modify-private user-library-read user-top-read"
    
    auth_manager = SpotifyOAuth(
        client_id=client_id,
        client_secret=os.getenv("SPOTIPY_CLIENT_SECRET"),
        redirect_uri=redirect_uri,
        scope=scope,
        cache_path=".spotify_cache"
    )
    
    return auth_manager.get_authorize_url()

def create_complete_playlist_from_ai(spotify_manager: SpotifyPlaylistManager, 
                                   ai_playlist_data: Dict, 
                                   max_tracks: int = 30) -> Optional[Dict]:
    """
    Create a complete Spotify playlist from AI-generated data
    """
    if not spotify_manager.is_authenticated():
        st.error("Please authenticate with Spotify first")
        return None
    
    user_info = spotify_manager.get_user_info()
    if not user_info:
        st.error("Could not get user information")
        return None
    
    # Extract data from AI response
    playlist_name = ai_playlist_data.get('playlist_name', 'AI Generated Playlist')
    description = ai_playlist_data.get('playlist_description', 'Created by Playlist Pal AI')
    search_terms = ai_playlist_data.get('search_terms', [])
    
    # Search for tracks
    st.write(f"🔍 Debug: Searching for tracks with terms: {search_terms}")
    tracks = spotify_manager.search_tracks(search_terms, limit=20)
    st.write(f"🔍 Debug: Found {len(tracks) if tracks else 0} tracks")
    
    if not tracks:
        st.error("No tracks found for the given search terms")
        return None
    
    # Sort by popularity and limit
    tracks = sorted(tracks, key=lambda x: x['popularity'], reverse=True)[:max_tracks]
    
    # Create playlist
    st.write(f"🔍 Debug: Creating playlist '{playlist_name}' for user {user_info['id']}")
    playlist_id = spotify_manager.create_playlist(
        user_id=user_info['id'],
        playlist_name=playlist_name,
        description=f"{description} | Generated by Playlist Pal AI"
    )
    st.write(f"🔍 Debug: Playlist ID: {playlist_id}")
    
    if not playlist_id:
        st.error("Failed to create playlist")
        return None
    
    # Add tracks to playlist
    track_ids = [track['id'] for track in tracks]
    st.write(f"🔍 Debug: Adding {len(track_ids)} tracks to playlist")
    success = spotify_manager.add_tracks_to_playlist(playlist_id, track_ids)
    st.write(f"🔍 Debug: Add tracks success: {success}")
    
    if success:
        return {
            'playlist_id': playlist_id,
            'playlist_name': playlist_name,
            'track_count': len(tracks),
            'tracks': tracks,
            'spotify_url': f"https://open.spotify.com/playlist/{playlist_id}"
        }
    else:
        st.error("Failed to add tracks to playlist")
        return None

